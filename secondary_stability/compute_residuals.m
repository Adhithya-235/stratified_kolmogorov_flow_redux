% SCRIPT: compute_residuals.m
%
% This script reconstructs the Afun operator using parameters from the
% .MAT file and folder names, then computes and stores residuals.
%
% This script is intended to be placed in the PARENT directory, alongside
% boussinesq.m and nonlinear_bs.m. The 'secondary_stability_solutions_maxit10000'
% folder should be a subdirectory within this PARENT directory.
%
% Example directory structure:
% <project_root_directory>/
%   compute_residuals.m (this script)
%   boussinesq.m
%   nonlinear_bs.m 
%   secondary_stability_solutions_maxit10000/  <-- Subdirectory
%     RebX.XX_alphaY.YY/
%       spectrum_RebX.XX_alphaY.YY.mat
%     ...
%

clear;
clc;
fprintf('Starting residual computation script (lives in parent directory)...\n');

% --- User Configuration ---
% !!! EDIT THIS VALUE BEFORE RUNNING !!!
% This Fr_input MUST be the same Froude number used when the 
% .MAT solution files were originally generated by stability_eigensolve.m
% It will be used for eigenvalue unscaling AND Afun reconstruction.
Fr_input = 0.01; % Example value, as per your note. Replace if it varied.

% Default Pr and beta for Afun reconstruction, as per your note.
Pr_val = 1.0;
beta_val = 0.0;

fprintf('Using Froude number (Fr_input) for unscaling and Afun: %f\n', Fr_input);
fprintf('Using Prandtl number (Pr_val) for Afun reconstruction: %f\n', Pr_val);
fprintf('Using beta (beta_val) for Afun reconstruction: %f\n', beta_val);

if isnan(Fr_input) || Fr_input <= 0
    error('Invalid Froude number set in script. Please edit Fr_input to be a positive numeric value.');
end

% --- Path Configuration ---
scriptDir = fileparts(mfilename('fullpath'));
if isempty(scriptDir) 
    % If run as a selection, mfilename might be empty. Assume current dir.
    scriptDir = pwd; 
    fprintf('Assuming script is running from: %s\n', scriptDir);
end
% Solutions directory is now a subdirectory of the script's directory
baseSolutionsDir = fullfile(scriptDir, 'solutions_branch_1_Pr_1');

% --- Get list of subdirectories ---
if ~isfolder(baseSolutionsDir)
    error(['Base solutions directory not found: %s\n' ...
           'Please ensure this script is in the parent directory of ' ...
           '''solutions_branch_1_Pr_1''.'], baseSolutionsDir);
end

listing = dir(baseSolutionsDir);
subDirs = {listing([listing.isdir]).name};
subDirs = subDirs(~ismember(subDirs,{'.','..'})); 

if isempty(subDirs)
    fprintf('No subdirectories found in %s.\n', baseSolutionsDir);
    return;
end

fprintf('Found %d potential solution subdirectories in %s.\n', length(subDirs), baseSolutionsDir);

dirPattern = '^Reb(\d{1,3}\.\d{2})_alpha(\d+\.\d{2})$';
processedCount = 0;
skippedCount = 0;

% --- Loop through subdirectories ---
for i = 1:length(subDirs)
    dirName = subDirs{i};
    fprintf('\nProcessing directory: %s\n', dirName);

    tokens = regexp(dirName, dirPattern, 'tokens');
    if isempty(tokens)
        fprintf('  Skipping directory (does not match expected pattern ''RebX.XX_alphaY.YY''): %s\n', dirName);
        skippedCount = skippedCount + 1;
        continue;
    end

    Reb_str = tokens{1}{1};
    alpha_str = tokens{1}{2};
    Reb_val = str2double(Reb_str);
    alpha_val = str2double(alpha_str);

    matFileName = sprintf('spectrum_%s.mat', dirName);
    matFilePath = fullfile(baseSolutionsDir, dirName, matFileName);

    if ~isfile(matFilePath)
        fprintf('  Skipping directory (MAT file not found): %s\n', matFilePath);
        skippedCount = skippedCount + 1;
        continue;
    end

    fprintf('  Loading MAT file: %s\n', matFilePath);
    try
        loadedData = load(matFilePath);
    catch ME
        fprintf('  Error loading MAT file %s: %s\n', matFilePath, ME.message);
        skippedCount = skippedCount + 1;
        continue;
    end

    requiredFields = {'eigvals', 'eigvecs', 'meta'};
    missingFields = setdiff(requiredFields, fieldnames(loadedData));
    if ~isempty(missingFields)
        fprintf('  Skipping MAT file (missing top-level fields: %s): %s\n', strjoin(missingFields, ', '), matFilePath);
        skippedCount = skippedCount + 1;
        continue;
    end
    if ~isfield(loadedData.meta, 'resolution')
        fprintf('  Skipping MAT file (missing meta.resolution): %s\n', matFilePath);
        skippedCount = skippedCount + 1;
        continue;
    end

    stored_eigvals = loadedData.eigvals; 
    eigvecs = loadedData.eigvecs;       
    Nx_meta = loadedData.meta.resolution(1); 
    Nz_meta = loadedData.meta.resolution(2); 

    if isempty(stored_eigvals) || isempty(eigvecs)
        fprintf('  Skipping MAT file (eigvals or eigvecs are empty): %s\n', matFilePath);
        skippedCount = skippedCount + 1;
        continue;
    end
    
    numEvals = length(stored_eigvals);
    expected_dim = 2 * Nx_meta * Nz_meta;
    if size(eigvecs, 1) ~= expected_dim || size(eigvecs, 2) ~= numEvals
        fprintf('  Skipping MAT file (eigenvector dimensions [%d x %d] inconsistent with meta.resolution [%d x %d] or numEvals [%d]): %s\n', ...
                size(eigvecs,1), size(eigvecs,2), Nx_meta, Nz_meta, numEvals, matFilePath);
        skippedCount = skippedCount + 1;
        continue;
    end
    
    fprintf('  Found %d eigenvalue/eigenvector pairs.\n', numEvals);
    fprintf('  Reconstructing Afun operator for Reb=%s, alpha=%s...\n', Reb_str, alpha_str);

    Afun_reconstructed = []; 
    
    try
        % nonlinear_bs.m and boussinesq.m should be found if they are in 
        % the same directory as this script (scriptDir), which is now assumed.
        rescale = Nx_meta / 128.0;
        [Xihat, Bhat, Psihat, Lx, Lz, Nx_bs, Nz_bs] = nonlinear_bs(Reb_val, rescale);
        
        if Nx_bs ~= Nx_meta || Nz_bs ~= Nz_meta
            fprintf('  Warning: Nx/Nz from nonlinear_bs (%d,%d) do not match meta.resolution (%d,%d).\n', Nx_bs, Nz_bs, Nx_meta, Nz_meta);
            fprintf('  Using Nx/Nz from meta.resolution for Kx, Kz definition, as eigenvectors depend on it.\n');
        end

        kxVals = (2*pi/Lx)*[0:(Nx_meta/2-1) (-Nx_meta/2):-1];
        kzVals = (2*pi/Lz)*[0:(Nz_meta/2-1) (-Nz_meta/2):-1];
        [Kx_grid, Kz_grid] = meshgrid(kxVals, kzVals);

        Afun_reconstructed = @(qhat) boussinesq(qhat, Xihat, Bhat, Psihat, Kx_grid, Kz_grid, ...
                                              alpha_val, beta_val, Lx, Lz, ...
                                              Fr_input, Pr_val, Reb_val);
        fprintf('  Afun reconstructed successfully.\n');
    catch ME_recon
        fprintf('  Error during Afun reconstruction (e.g., calling nonlinear_bs or boussinesq): %s\n', ME_recon.message);
        fprintf('  Ensure nonlinear_bs.m and boussinesq.m are in the script''s directory ''%s'' and have no issues.\n', scriptDir);
        skippedCount = skippedCount + 1;
        continue; 
    end
    
    fprintf('  Calculating residuals using reconstructed Afun...\n');
    residuals_norm = zeros(numEvals, 1);
    lambda_operator = stored_eigvals / Fr_input; 

    computationFailedForFile = false;
    for j = 1:numEvals
        v_j = eigvecs(:, j);
        lambda_op_j = lambda_operator(j);
        
        try
            % Afun_reconstructed calls boussinesq.m, which should be in scriptDir
            Av_j = Afun_reconstructed(v_j); 
        catch ME_afun_call
            fprintf('    Error evaluating reconstructed Afun for eigenvector %d: %s\n', j, ME_afun_call.message);
            fprintf('    This implies an issue within boussinesq.m or its dependencies.\n');
            fprintf('    Skipping residual calculation for the rest of this file.\n');
            computationFailedForFile = true;
            break; 
        end
        
        residual_vector = Av_j - lambda_op_j * v_j;
        residuals_norm(j) = norm(residual_vector);
        
        if mod(j,10) == 0 || j == numEvals
            fprintf('    Calculated residual for eigenpair %d/%d: %e\n', j, numEvals, residuals_norm(j));
        end
    end
    
    if computationFailedForFile
        skippedCount = skippedCount + 1;
        continue; 
    end

    try
        fprintf('  Saving residuals_norm to %s\n', matFilePath);
        save(matFilePath, 'residuals_norm', '-append');
        fprintf('  Successfully appended residuals_norm.\n');
        processedCount = processedCount + 1;
    catch ME_save
        fprintf('  Error saving residuals_norm to %s: %s\n', matFilePath, ME_save.message);
        fprintf('  Please ensure you have write permissions and the file is not locked.\n');
        skippedCount = skippedCount + 1;
    end
end

fprintf('\n--- Processing Complete ---\n');
fprintf('Successfully processed and appended residuals to %d MAT files.\n', processedCount);
fprintf('Skipped %d directories/files due to errors or mismatches.\n', skippedCount);